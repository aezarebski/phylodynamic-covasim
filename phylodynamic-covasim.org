#+title: Phylodynamic Covasim

[[https://covasim.idmod.org/][Covasim]]

#+begin_src python :noweb no-export :tangle pdc.py
  <<imports>>
  
  <<configuration>>
#+end_src

* Intervention: Testing

We construct and object to represent daily testing of each symptomatic
individuals to represent sampling in the sense of birth-death-sampling models.
There are a lot more options that could be set for this but this seems like a
reasonable starting point.

#+begin_src python :tangle pdc.py
test_spec = cv.test_prob(
    symp_prob = CONFIG["daily_testing"]["prob"],
    start_day = CONFIG["daily_testing"]["start_date"],
    end_day = CONFIG["daily_testing"]["end_date"]
)
#+end_src

* Simulate

Make a simulation object and run that simulation.

#+begin_src python :tangle pdc.py
sim = cv.Sim(
    CONFIG["params"],
    interventions=test_spec
)
sim.set_seed(CONFIG["sim"]["initial_seed"])
sim.run()
#+end_src

but we want to make sure that there are at least two diagnosed cases so we will
loop the simulation until this is the case.

#+begin_src python :tangle pdc.py
sim_count = 1
while sim_count < CONFIG["sim"]["maximum_repeats"]:
    if sim.summary["cum_diagnoses"] > 1:
        break
    else:
        print("repeating the simulation...")
        sim = cv.Sim(
            CONFIG["params"],
            interventions=test_spec
        )
        sim.set_seed(CONFIG["sim"]["initial_seed"] + sim_count)
        sim.run()
        sim_count += 1
#+end_src

* TODO Reconstructed tree

To reconstruct the tree connecting the sampled individuals we need to pull out
some data.

** Extract the data

#+begin_src python :tangle pdc.py
all_people = sim.people.to_people()
transmission_tree = sim.make_transtree(to_networkx=True)
seed_uids = [
    e["target"]
    for e in transmission_tree.infection_log
    if e["layer"] == "seed_infection"
]
diagnosed_people = [p for p in all_people if p.diagnosed]
#+end_src

** Tree assembly

To extract the reconstructed tree we do two passes over the full transmission
tree(s). The first moves from the leaves to the root to build up a list of all
of the individuals that are relevant to the reconstructed tree. The second goes
from root to leaves building up a representation of the reconstructed tree up to
the level of resolution permitted by covasim. The modelling assumptions of
covasim mean that the result of the previous step is not necessarily a binary
tree hence further post-processing is necessary.

The =first_pass_uids= function computes the result of the first pass.

#+begin_src python :tangle pdc.py
def first_pass_uids(leaf_people: List[cv.Person],
                    tt: cv.TransTree,
                    max_loops: int) -> Set[np.int32]:
    """return a list of all the people that are ancestral to one of the leaf
    people."""
    curr_people = set()
    for p in leaf_people:
        curr_people.add(p.uid)
    next_people = set()

    result = set()
    for p in curr_people:
        result.add(p)

    loop_counter = 0
    while loop_counter < max_loops:
        for cp in curr_people:
            for np in tt.graph.predecessors(cp):
                if np is not None:
                    next_people.add(np)

        if len(next_people) > 0:
            for p in next_people:
                result.add(p)
            curr_people, next_people = next_people, set()
            loop_counter += 1
        else:
            break

    return result
#+end_src

We can then extract the subgraph containing just these nodes.

#+begin_src python :tangle pdc.py
fp_uids = first_pass_uids(diagnosed_people, transmission_tree, 100)
almost_rt = transmission_tree.graph.subgraph(fp_uids)
#+end_src

** Visualisation of transmission

The figure below shows the transmission tree restricted to just those paths from
root to leaf of the reconstructed tree. Consequently, it is not necessarily a
binary tree and there are internal nodes which would not be included in the
final reconstructed tree.

#+begin_src python :tangle pdc.py
nx.draw_planar(almost_rt, with_labels = True)
plt.savefig("demo-almost-rt.png")
plt.clf()
#+end_src

[[./demo-almost-rt.png]]

* Configuration

#+name: configuration
#+begin_src python
CONFIG = {
    "params": {
        "pop_size": 2e3,
        "pop_infected": 1,
        "start_day": '2020-04-01',
        "end_day": '2020-05-25'
    },
    "daily_testing": {
        "prob": 0.1,
        "start_date": '2020-04-02',
        "end_date": '2020-05-25'
    },
    "output_json": "demo.json",
    "sim": {
        "maximum_repeats": 5,
        "initial_seed": 1
    }
}
#+end_src

* Requirements

There are some packages that we need.

#+name: imports
#+begin_src python
import json as json
import sciris as sc
import covasim as cv
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from typing import List, Set
#+end_src

The code here should run in a virtual environment; there is a =requirements.txt=
file specifying the packages. To create the environment use the following

#+begin_src sh
python3 -m venv venv
source venv/bin/activate
pip install -U pip   # update pip
pip install -r requirements.txt
#+end_src

To get a copy of the exact version of =covasim= that we are using there are a
couple of variables to inspect.

#+begin_src python :tangle pdc.py
print(sim.version)
print(sim.git_info)
#+end_src

